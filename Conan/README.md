In a C++ project using Conan + CMake presets, think of your workflow much like a JavaScript project with npm scripts and a `package.json`. Here’s how the pieces map—and what those two Conan commands actually do:

1. Declaring your dependencies  
   -  In JS: you list `"lodash": "^4.17.21"` under `"dependencies"` in package.json.  
   -  In C++/Conan: you list `“boost/1.82.0”` and `“fmt/10.1.1”` under `requires = [...]` in your `conanfile.py` (or `conanfile.txt`).  
   This file is your project’s “package.json”—it tells Conan “I need these libraries.”

2. Installing (and building) dependencies  
   -  In JS: you run `npm install`, which reads package.json, downloads each package, and puts it in `node_modules`.  
   -  In C++: you run `conan install . --build=missing`. Conan reads your `conanfile`, downloads any pre-built binaries for Boost, fmt, etc., and if it can’t find a matching binary, it compiles the library from source (that’s the `--build=missing` part). It then generates a set of CMake configuration files—much like a `node_modules/.bin` folder plus lockfile—so your build system knows exactly where to find each library.

3. CMake presets as “npm scripts”  
   Instead of typing a long CMake invocation by hand, you define presets in `CMakePresets.json` (generated by Conan). Those presets are the C++ equivalent of npm scripts. For example:

   ```jsonc
   {
     "version": 3,
     "configurePresets": [
       {
         "name": "dev",
         "generator": "Ninja",
         "binaryDir": "${sourceDir}/build",
         "cacheVariables": {
           "CMAKE_BUILD_TYPE": "Debug"
         }
       }
     ],
     "buildPresets": [
       {
         "name": "dev",
         "configurePreset": "dev"
       }
     ]
   }
   ```

   Now your workflow looks like:

     -  `conan install . --build=missing --preset dev`  
       → reads your dependencies, installs/builds them, and writes CMake toolchain files.  
     -  `cmake --preset dev`  
       → configures the project using those toolchain files (i.e., your “installed” libraries).  
     -  `cmake --build --preset dev`  
       → compiles your code, linking against Boost and fmt automatically.

In other words:  
– **`conanfile.py` ≈ `package.json`**  
– **`conan install` ≈ `npm install`**  
– **CMake presets ≈ npm scripts** (short, repeatable commands to configure/build your project)

This setup keeps your day-to-day workflow as simple as `npm install && npm run build`, except in C++ you do:

   ```
   conan install . --build=missing --preset dev
   cmake --build --preset dev
   ```

and let Conan + CMake handle all of the heavy lifting of fetching, building, and wiring up your third-party libraries.