
## Guideline: Avoid const member variables in class

The C++ Core Guidelines recommend avoiding `const` member variables for several reasons. Here are some key points:

1. **Immutability and Initialization**:
   - `const` member variables must be initialized at the point of declaration or in the constructor initializer list. This can complicate the construction process, especially if the initialization logic is complex or if it depends on runtime information.
   - Once set, a `const` member cannot be modified, which can limit the flexibility of the class. This immutability can sometimes make it difficult to implement certain algorithms or behaviors that require modification of all member variables.

2. **Assignment Operator and Move Semantics**:
   - `const` member variables can interfere with the automatically generated assignment operator. Since `const` members cannot be assigned after initialization, the compiler-generated assignment operator will not work if the class contains `const` members.
   - Similarly, move semantics (move constructors and move assignment operators) can be problematic. Moving typically involves transferring resources from one object to another, which often necessitates modifying the member variables.

3. **Consistency and State Management**:
   - `const` members can lead to inconsistencies in the internal state management of a class. Since they cannot be changed after initialization, developers might need to introduce additional mutable state or external management logic to handle scenarios where the `const` member needs to be logically modified.
   - Maintaining `const` correctness throughout a complex class hierarchy can be challenging and might introduce subtle bugs or design complications.

4. **Design Considerations**:
   - From a design perspective, it is often better to use other mechanisms to enforce immutability or const-correctness. For example, providing `const` member functions (which guarantee that the function does not modify the object) can be a more flexible and maintainable approach.
   - Using `const` member functions allows the interface to express immutability without imposing the constraints on the internal state management of the class.

### Example

Hereâ€™s an illustrative example to show some of the complications:

```cpp
class Example {
    const int value; // const member

public:
    Example(int v) : value(v) {} // Must be initialized in the constructor

    // Copy assignment operator would not be generated by the compiler
    Example& operator=(const Example& other) = delete;
};
```

In the example above, the `const` member `value` must be initialized in the constructor initializer list. Additionally, the compiler will not generate a copy assignment operator due to the presence of the `const` member, potentially complicating object management.

### Alternatives

Instead of `const` member variables, consider:

- Using `const` member functions to prevent modification of the object state.
- Using `private` member variables with controlled access through `getter` functions that return `const` references or values.
- Providing a clear and consistent interface that ensures immutability where necessary without imposing strict internal constraints.

### Conclusion

While `const` member variables can be useful in certain scenarios, their use can introduce complexities and limitations in class design and object management. The C++ Core Guidelines recommend avoiding them to promote more flexible, maintainable, and robust code.